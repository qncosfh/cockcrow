package exploit

import (
	"bufio"
	"crypto/tls"
	"errors"
	"fmt"
	"io/ioutil"
	"math/rand"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"time"
)

// defaultHeaders 返回默认的 HTTP 头
func defaultHeaders() map[string]string {
	userAgents := []string{
		"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36",
		"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36",
		"Mozilla/5.0 (Linux; Android 10; SM-G973F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Mobile Safari/537.36",
		"Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/537.36 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1",
	}

	rand.Seed(time.Now().UnixNano())
	return map[string]string{
		"User-Agent":      userAgents[rand.Intn(len(userAgents))],
		"Connection":      "keep-alive",
		"Accept":          "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
		"Accept-Language": "en-US,en;q=0.5",
		"Accept-Encoding": "gzip, deflate, br",
		"Content-Type":    "application/x-www-form-urlencoded; charset=UTF-8",
	}
}

// mergeHeaders 合并默认头与模板头
func mergeHeaders(defaults, templateHeaders map[string]string) map[string]string {
	for key, value := range templateHeaders {
		// 如果模板中有对应头，覆盖默认值
		defaults[key] = value
	}
	return defaults
}

type Config struct {
	Target  string   // 单一目标
	Targets []string // 目标列表
	Type    string   // 漏洞类型
}

var config Config
var basePath = "dict/exploit/WebPoc"

// SetOption 设置配置项
func SetOption(option, value string) error {
	if strings.TrimSpace(value) == "" {
		return errors.New("value cannot be empty")
	}

	if strings.ToLower(option) == "targets" && strings.HasSuffix(value, ".txt") {
		fileTargets, err := readLines(value)
		if err != nil {
			return fmt.Errorf("failed to read targets file: %v", err)
		}
		config.Targets = fileTargets
		return nil
	}

	values := strings.Split(value, ",")
	for i := range values {
		values[i] = strings.TrimSpace(values[i])
	}

	switch strings.ToLower(option) {
	case "target":
		if len(config.Targets) > 0 {
			return errors.New("you cannot set 'target' and 'targets' at the same time")
		}
		config.Target = values[0]
	case "targets":
		if len(config.Target) > 0 {
			return errors.New("you cannot set 'target' and 'targets' at the same time")
		}
		config.Targets = values
	case "type":
		config.Type = strings.Join(values, ",")
	default:
		return fmt.Errorf("invalid option: %s. Supported options are 'target', 'targets' or 'type'", option)
	}
	return nil
}

// Execute 执行漏洞利用任务
func Execute() error {
	if basePath == "" {
		return errors.New("basePath is not set")
	}

	if len(config.Target) == 0 && len(config.Targets) == 0 {
		return errors.New("no configuration provided: please set 'target' or 'targets'")
	}

	// 如果用户未指定 type，遍历所有子目录和文件
	var exploitDirs []string
	if config.Type == "" {
		logInfo("No type specified, scanning all directories under WebPoc...")
		files, err := listAllFiles(basePath)
		if err != nil {
			return fmt.Errorf("failed to list files under basePath: %v", err)
		}
		exploitDirs = files
	} else {
		exploitDirs = []string{filepath.Join(basePath, config.Type)}
	}

	var mdFiles []string
	for _, dir := range exploitDirs {
		files, err := listMdFiles(dir)
		if err != nil {
			logError(fmt.Sprintf("Failed to list md files in %s: %v", dir, err))
			continue
		}
		mdFiles = append(mdFiles, files...)
	}

	if len(mdFiles) == 0 {
		return errors.New("no exploit templates found")
	}

	logInfo(fmt.Sprintf("Found %d exploit templates", len(mdFiles)))

	// 处理目标
	for _, target := range append([]string{config.Target}, config.Targets...) {
		if target == "" {
			continue
		}

		// 遍历模板文件
		for _, file := range mdFiles {
			exploitTemplate, err := parseExploitTemplate(file)
			if err != nil {
				logError(fmt.Sprintf("Failed to parse template %s: %v", file, err))
				continue
			}

			err = executeExploit(target, exploitTemplate)
			if err != nil {
				logError(fmt.Sprintf("Failed to exploit target %s with template %s: %v", target, file, err))
			}
		}
	}

	logInfo("Exploit task completed.")
	return nil
}

// listMdFiles 列出指定目录下的所有 md 文件
func listMdFiles(dir string) ([]string, error) {
	var files []string
	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && strings.HasSuffix(info.Name(), ".md") {
			files = append(files, path)
		}
		return nil
	})
	return files, err
}

// listAllFiles 遍历目录下的所有文件夹和文件
func listAllFiles(dir string) ([]string, error) {
	var files []string
	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			files = append(files, path)
		}
		return nil
	})
	return files, err
}

// extractRequestInfo 从payload中提取请求方法和路径
func extractRequestInfo(payload string) (method, path string, headers map[string]string, body string, err error) {
	lines := strings.Split(payload, "\n")
	if len(lines) < 1 {
		return "", "", nil, "", errors.New("invalid payload format")
	}

	// 提取方法和路径
	firstLine := strings.Fields(lines[0])
	if len(firstLine) < 2 {
		return "", "", nil, "", errors.New("invalid request line in payload")
	}
	method = firstLine[0]
	path = firstLine[1]

	// 提取头部和请求体
	headers = make(map[string]string)
	var bodyLines []string
	for i, line := range lines[1:] {
		if strings.TrimSpace(line) == "" {
			bodyLines = lines[i+2:] // 请求体开始
			break
		}
		parts := strings.SplitN(line, ": ", 2)
		if len(parts) == 2 {
			headers[parts[0]] = parts[1]
		}
	}
	body = strings.Join(bodyLines, "\n")
	return
}

// executeExploit 执行漏洞验证
func executeExploit(target string, template ExploitTemplate) error {
	method, path, templateHeaders, body, err := extractRequestInfo(template.Payload)
	if err != nil {
		return fmt.Errorf("failed to extract request info from payload: %v", err)
	}

	parsedURL, err := url.Parse(target)
	if err != nil {
		return fmt.Errorf("invalid target URL: %s", target)
	}
	hostHeader := parsedURL.Host
	body = strings.Replace(body, "{HOST}", hostHeader, -1)
	path = strings.Replace(path, "{HOST}", hostHeader, -1)

	fullURL := fmt.Sprintf("%s://%s%s", parsedURL.Scheme, hostHeader, path)

	defaults := defaultHeaders()
	mergedHeaders := mergeHeaders(defaults, templateHeaders)

	req, err := http.NewRequest(method, fullURL, strings.NewReader(body))
	if err != nil {
		return fmt.Errorf("failed to create request: %v", err)
	}

	for key, value := range mergedHeaders {
		req.Header.Set(key, value)
	}
	if req.Header.Get("Host") == "" {
		req.Header.Set("Host", hostHeader)
	}

	// 跳过证书验证
	client := &http.Client{
		Transport: &http.Transport{
			Proxy:           http.ProxyFromEnvironment, // 使用系统代理
			TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		},
		Timeout: 7 * time.Second, // 设置超时时间为 7 秒
	}

	resp, err := client.Do(req)
	if err != nil {
		if os.IsTimeout(err) || strings.Contains(err.Error(), "Client.Timeout") {
			logError(fmt.Sprintf("Timeout when exploiting target %s with template %s", target, template.Source))
		} else {
			return fmt.Errorf("failed to send request: %v", err)
		}
		return nil
	}
	defer resp.Body.Close()

	if template.ExpectedCode != "" && fmt.Sprintf("%d", resp.StatusCode) != template.ExpectedCode {
		return fmt.Errorf("unexpected response code: got %d, want %s", resp.StatusCode, template.ExpectedCode)
	}

	bodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read response body: %v", err)
	}

	if template.ResponseMatch != "" && !strings.Contains(string(bodyBytes), template.ResponseMatch) {
		return fmt.Errorf("response does not contain expected match: %s", template.ResponseMatch)
	}

	logInfo(fmt.Sprintf("[+] Vulnerability found: %s", template.Source))
	return nil
}

// ExploitTemplate 漏洞模板结构
type ExploitTemplate struct {
	Title         string            // 标题
	UpdateTime    string            // 更新时间
	ID            string            // 漏洞编号
	Description   string            // 漏洞说明
	BodyMatch     string            // 漏洞特征
	ScriptType    string            // 验证脚本类型
	Payload       string            // 验证脚本内容
	ExpectedCode  string            // 响应代码特征
	ResponseMatch string            // 响应内容特征
	UploadPath    string            // 上传文件定位
	Source        string            // 验证文件来源
	Headers       map[string]string // 请求头
	Remarks       string            // 备注说明
}

// parseExploitTemplate 提取模板内容
func parseExploitTemplate(filePath string) (ExploitTemplate, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return ExploitTemplate{}, err
	}
	defer file.Close()

	var template ExploitTemplate
	template.Headers = make(map[string]string)
	template.Source = filePath // 保存文件路径

	var remarks []string // 用于保存备注说明
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		switch {
		case strings.HasPrefix(line, "# "):
			template.Title = strings.TrimPrefix(line, "# ")
		case strings.HasPrefix(line, "> 更新时间："):
			template.UpdateTime = strings.TrimPrefix(line, "> 更新时间：")
		case strings.HasPrefix(line, "> 漏洞编号："):
			template.ID = strings.TrimPrefix(line, "> 漏洞编号：")
		case strings.HasPrefix(line, "> 漏洞说明："):
			template.Description = strings.TrimPrefix(line, "> 漏洞说明：")
		case strings.HasPrefix(line, "> 漏洞特征："):
			template.BodyMatch = strings.TrimPrefix(line, "> 漏洞特征：")
		case strings.HasPrefix(line, "> 验证脚本："):
			template.ScriptType = strings.TrimPrefix(line, "> 验证脚本：")
		case strings.HasPrefix(line, "```"):
			var payloadLines []string
			for scanner.Scan() {
				payloadLine := scanner.Text()
				if strings.TrimSpace(payloadLine) == "```" {
					break
				}
				payloadLines = append(payloadLines, payloadLine)
			}
			template.Payload = strings.Join(payloadLines, "\n")
		case strings.HasPrefix(line, "> 响应代码特征："):
			template.ExpectedCode = strings.TrimPrefix(line, "> 响应代码特征：")
		case strings.HasPrefix(line, "> 响应内容特征："):
			template.ResponseMatch = strings.TrimPrefix(line, "> 响应内容特征：")
		case strings.HasPrefix(line, "> 上传文件定位："):
			template.UploadPath = strings.TrimPrefix(line, "> 上传文件定位：")
		case strings.HasPrefix(line, "> 验证文件来源："):
			template.Source = strings.TrimPrefix(line, "> 验证文件来源：")
		case line == "备注说明：":
			for scanner.Scan() {
				remarks = append(remarks, scanner.Text())
			}
		}
	}

	// 处理备注说明
	if len(remarks) > 0 {
		template.Remarks = strings.Join(remarks, "\n")
	}

	return template, scanner.Err()
}

// logInfo 记录信息日志
func logInfo(msg string) {
	fmt.Println("\u001B[32m" + msg + "\u001B[0m")
}

// logError 记录错误日志
func logError(msg string) {
	fmt.Println(msg)
}

// readLines 从文件中读取每行内容
func readLines(filePath string) ([]string, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var lines []string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		lines = append(lines, scanner.Text())
	}
	return lines, scanner.Err()
}
